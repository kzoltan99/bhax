<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Stroustrup!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>JDK osztályok</title>
        <para>
		Írjunk olyan Boost C++ programot (indulj ki például a fénykardból) amely kilistázza a JDK összes
osztályát (miután kicsomagoltuk az src.zip állományt, arra ráengedve)!

        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
	    </para>
    <para>
	    Ezt a feladatot a leírásban ajánlott Bátfai Tanár Úr által készített fenykard.cpp alapján készítettem el.
	    </para>
    <para>
	    Azért jó kiindulási kód a fénykard mert ebben is állományok kilistázása valamint rekurzív bejárás megvalósítása történik.
	    Ezt a feladatot itt a forrás 72. sorában található read_acts függvény végzi el, viszont nekünk ezen kell változtatnunk, 
	    mivel mi a JDK osztályait akarjuk majd kilistázni.
	    </para>
    <para>
	    <programlisting><![CDATA[
void read_acts(boost::filesystem::path path, std::map <std::string, int> &acts)
{

    if (is_regular_file(path)) {

        std::string ext(".props");
        if (!ext.compare(boost::filesystem::extension(path))) {

            std::string actpropspath = path.string();
            std::size_t end = actpropspath.find_last_of("/");
            std::string act = actpropspath.substr(0, end);

            acts[act] = get_points(path);

            std::cout << std::setw(4) << acts[act] << "    " << act << std::endl;
        }


    } else if (is_directory(path))
        for (boost::filesystem::directory_entry & entry : boost::filesystem::directory_iterator(path))
            read_acts(entry.path(), acts);

}]]></programlisting>
	    </para>
    <para>
	    Ahogy itt láthatjuk a kódcsipetben ez a függvény a .props állományokat listázza ki nekünk. Ezt módosítjuk úgy, hogy a
	    .java állományokkal tegye ezt. Ezt úgy tudjuk megvalósítani, hogy egy kicsit fargunk ebból a függvényből, vagyis az act-okat
	    kitöröljük mivel számunkra azok lényegtelenek. Egy egyszerű push_back-el hellyetesítjük, és a .props valamint acts előfordulásokat
	    rendre .java és Classes előfordulásra cseréljük.
	    </para>
    <para>
	    Így néz ki a számunkra megfelelő verzió:
	    <programlisting><![CDATA[
void readClasses(boost::filesystem::path path, vector<string>& classes){
	if (is_regular_file(path)){
		std::string ext(".java");
		if (!ext.compare(boost::filesystem::extension(path))){
			classes.push_back(path.string());
		}
	}
	else if (is_directory(path))
		for (boost::filesystem::directory_entry & entry : boost::filesystem::← directory_iterator(path))
		readClasses(entry.path(), classes);
}]]></programlisting>
	    </para>
    <para>
	    És ezekkel a változatásokkal sikerült elérni a célunkat vagyis, hogy a programunk rekurzívan bejárja a kapott állományt és abból az
	    összes .java-t kilistázza nekünk.
        </para>
    </section>        


    <section>
        <title>Másoló-mozgató szemantika</title>
        <para>
		Kódcsipeteken (copy és move ctor és assign) keresztül vesd össze a C++11 másoló és a mozgató
szemantikáját, a mozgató konstruktort alapozd a mozgató értékadásra!

        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        


    <section>
        <title>Hibásan implementált RSA törése</title>
        <para>
		Készítsünk betű gyakoriság alapú törést egy hibásan implementált RSA kódoló:
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_3.pdf (71-73 fólia) által
készített titkos szövegen.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        


    <section>
		<title>Változó argumentumszámú ctor</title>
		<para>
Készítsünk olyan példát, amely egy képet tesz az alábbi projekt Perceptron osztályának bemenetére
és a Perceptron ne egy értéket, hanem egy ugyanakkora méretű „képet” adjon vissza. (Lásd még a 4
hét/Perceptron osztály feladatot is.)
		</para>
	<para>
	A feladatot az előző csokorban szereplő perceptronos feladat alapján csináltam meg. A forrás nagy része így megegyezik.
		</para>
<para>Mivel többrétegű perceptront fogunk alkalmazni ezért meg kell tennünk a megfelelő include-okat. Ezek névszerint az mlp és a png kép használata végett a png könyvtárak.
	<programlisting><![CDATA[
#include <iostream>
#include "mlp.hpp"
#include <png++/png.hpp>]]></programlisting>
	</para>
	<para>
	Maga a forrás nem túl hosszú. Először is beolvassuk a képet (get_width, get_height) és a new operátorral létrehozzuk a perceptront.
	<programlisting><![CDATA[
int main(int argc, char ++argv){
png::image <png::rgb_pixel> png_image(argv[1]);
int size = png_image.get_width()*png_image.get_height();
Perceptron *p = new Perceptron(3, size, 256, 1);]]></programlisting>
	</para>
	<para>
	Aztán létre kell hoznunk egy double változót. Utána szépen végigmegyünk a kép magasság/szélesség pontjain for ciklusokkal. Az image fogja tárolni azt a színkomponenst amit a kódban megadtunk. A value pedig majd azt a double-t fogja tárolni amit a végén kiíratunk.
	<programlisting><![CDATA[
	double* image = new double[size];
for(int i = 0; i<png_image.get_width(); ++i)
	for(int j = 0; i<png_image.get_height(); ++j)
	image[i*png_image.get_width()+j] = png_image[i][j].red;
double value = (*p) (image);
cout << value << endl;]]></programlisting>
</para>
	<para>
	Ezek után jöhetnek a változtatások az eredeti perceptronos feladathoz képest. Most azt szeretnénk, hogy egy képet generáljon nekünk a program nem pedig értékeket írjon.
	Ezt végrehajtandó implementálunk két új for ciklust az előzőekkel megfelelő céllal valamint double*-ot fogunk használni a sima double helyett. Ezek azért szükségesek, hogy
	a megfelelő végeredményt kapjuk, vagyis a képünk megfelelő adatokat kapjon a sikeres generáláshoz és a write png kiterjesztésű képet alkosson nekünk.
	<programlisting><![CDATA[
double* newPicture = (*p) (image);
for(int i=0; i<png_image.get_width(); ++i)
for(int j=0; j<png_image.get_height(); ++j)
	png_image[i][j].red = newPicture[i*png_image.get_width()+j];
png_image.write("output.png");]]></programlisting>
</para>
	<para>
	A kódunk végén pedig elvégezzük a szükséges hely felszabadítást a memóriában, amit a következő képpen teszünk:
	<programlisting><![CDATA[
delete p;
delete [] image;]]></programlisting>
</para>
	<para>
	Ahhoz, hogy minden probléma nélkül fusson már csak annyit kell tennünk, hogy az mlp.hpp header fájlban is átírjuk a double-t double*-ra, mivel azt szeretnénk, hogy visszaadja.
	<programlisting><![CDATA[
double* operator() ( double image [] )]]></programlisting>
</para>
		</section>


    <section>
        <title>Összefoglaló</title>
        <para>
		Az előző 4 feladat egyikéről írj egy 1 oldalas bemutató „”esszé szöveget!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
   
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
